b'\xf5\xbb%\x00\x00\n# import Files\nimport json\nimport os\nimport platform\nimport random\nimport threading\nimport time\nimport requests\n\nfrom colorama import Fore\n\ndef center(var:str, space:int=None): # From Pycenter\n    if not space:\n        space = (os.get_terminal_size().columns - len(var.splitlines()[int(len(var.splitlines())/2)])) / 2\n    \n    return "\n".join((\' \' * int(space)) + var for var in var.splitlines())\n\n\nos.system("cls")\nclass checker:\n\n    online = None\n    path = None\n    ModeRun = None\n\n    Found = [] #[0] users\n    FoundNumber = 0\n    number = 0\n    bad = 0\n    Unavailable = 0\n\n\n    def setPath(self, path):\n        self.path = str(path) + f"@[{platform.node()}] $"\n    \n    def getPath(self):\n        return self.path\n    \n    def __init__(self): \n\n        self.animation()\n        \n        self.setPath("checker")\n\n        value = self.cheackToolIsOnline()\n        if value == "offline":\n            self.offline()\n        else:\n            threading.Thread(target=self.run).start()\n\n    def animation(self, back = False):\n\n        os.system("cls")\n        text = """\n            _               _       \n       __ _| |__   ___  ___| |_ ___ \n      / _` | \'_ \\ / _ \\/ __| __/ __|\n     | (_| | | | | (_) \\__ \\ |_\\__ \\\n      \\__, |_| |_|\\___/|___/\\__|___/\n      |___/                         \n\n                ___\n              _/ 66\\\n             ( \\  ^/__\n              \\    \\__)\n              /     \\\n        001  /      _\\\n             ```````\n            """\n\n        faded = \'\'\n        red = 40\n\n        for line in text.splitlines():\n            faded += (f"\x1b[38;2;{red};0;220m{line}\x1b[0m\n")\n            if not red == 255:\n                red += 15\n                if red > 255:\n                    red = 255\n\n        if back == False:\n            print(center(faded))\n            \n            timer = 0#5\n\n            while timer >= 0:\n                print(center(str(timer)), end="\r")\n                time.sleep(1)\n                timer = timer - 1\n\n\n        else:\n            return text\n\n\n    def offline(self):\n        os.system("cls")\n        textArt = f"""{Fore.RED}\n                          .-.\n             heehee      /aa \\_\n                       __\\-  / )                 .-.\n             .-.      (__/    /        haha    _/oo \\\n           _/ ..\\       /     \\               ( \\v  /__\n          ( \\  u/__    /       \\__             \\/   ___)\n           \\    \\__)   \\_.-._._   )  .-.       /     \\{Fore.LIGHTRED_EX}This Tool Is Offline{Fore.RED}\n           /     \\             `-`  / ee\\_    /       \\_\n        __/       \\               __\\  o/ )   \\_.-.__   )\n       (   _._.-._/     hoho     (___   \\/           \'-\'\n    001 \'-\'                        /     \\\n{Fore.LIGHTRED_EX}try another time{Fore.RED}                 _/       \\    teehee\n                                (   __.-._/{Fore.RESET}"""\n        print(center(textArt))\n        input()\n        exit()\n\n        \n\n\n\n    def cheackToolIsOnline(self):\n        \n        cheack = requests.get("https://raw.githubusercontent.com/iqnvo/SourceCodeCheacker/main/status.py").text\n\n        try:\n            if (\'"app": True\') in str(cheack):\n                app = "online"\n            else:\n                app = "offline"\n\n        except:\n            app = "offline"\n\n            \n\n        finally:\n            print(cheack)\n            cheack = None\n            return app\n            \n    def getHeadersLogin(self):\n        headers = {\n            \'cookie\': \'csrftoken=missing; mid=missing\',\n            \'user-agent\': \'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36\',\n            \'sec-ch-ua-platform\': \'"Windows"\',\n            \'x-csrftoken\': \'missing\'\n        }\n        return headers\n    \n    def getUrlLogin(self):\n        return "https://www.instagram.com/accounts/login/ajax/"\n    \n    def getPayloadLogin(self, username):\n        payload = {\n            \'username\': username,\n            \'enc_password\': \'#PWD_INSTAGRAM_BROWSER:0:&:{}\'.format(username)\n        }\n        return payload\n\n    #<cheakers>\n    def cheackRandom(self, long, File = None):\n        self.online = False\n        \n\n        while True:\n            username = "".join(random.choice("qazwsxedcrfvtgbyhnujmikolp1234567890")for i in range(long))\n\n            try:\n                cheack = requests.post(self.getUrlLogin(), headers=self.getHeadersLogin(), data=self.getPayloadLogin(username)).text\n                \n                if (\'"message":"Sorry, your password was incorrect. Please double-check your password."\') in cheack or (\'"user":false\') in cheack:\n                    \n                    self.Found.append(username)\n                    self.FoundNumber +=1\n\n                    with open("Found.txt", "a") as File:\n                        File.write(username + "\n")\n                        File.close()\n\n                elif (\'"user":true\') in cheack:\n                    self.number +=1\n                    self.Unavailable +=1\n\n\n\n                else:\n                    self.bad +=1\n            except:\n                self.bad +=1\n\n            finally:\n                os.system("cls")\n                print(f"{Fore.LIGHTYELLOW_EX}BAD [{self.bad}]{Fore.LIGHTBLUE_EX}, {Fore.LIGHTGREEN_EX}Found [{self.FoundNumber}]{Fore.LIGHTBLUE_EX}, {Fore.LIGHTRED_EX}Unavailable [{self.Unavailable}]{Fore.RESET}\n", end="\r")\n                #time.sleep(int(random.choice([19, 9, 30, 7, 15, 18])))\n                time.sleep(int(7))\n\n\n\n    def listCheaker(self):\n        return f"""{Fore.LIGHTYELLOW_EX}[+] normal\n{Fore.LIGHTRED_EX}[UPDATE] soon...{Fore.RESET}"""\n    #</cheakers>\n    \n    def cleanLin(self, Lin):\n        t1 = None\n        __text = ""\n\n        for text in Lin:\n            \n            if text == " " and t1 == None:\n                __text = __text + text\n                t1 = True\n            elif text == " " and t1 != None:\n                pass\n            else:\n                __text = __text + text\n                t1 = None\n        \n\n        \n        print(__text)\n        return __text.split(" ")\n                \n\n\n\n    def checkFile(self, File):\n        try:\n            open(File, "r").close()\n            return True\n        except FileNotFoundError:\n            return False\n                    \n                \n            \n\n    def setCommand(self, command):\n        command = self.cleanLin(command)\n        command1 = command[0]\n\n        if command1 == "normal": #normal checker\n            t1 = None\n\n            try:\n                command[2]\n                t1 = True\n            except IndexError:\n                t1 = False\n            \n            try:\n                if t1 == True:\n                    if self.checkFile(command[2]) == True:\n                        #threading.Thread(target=self.cheackRandom, args=(int(command[1]), command[2])).start()\n                        self.cheackRandom(int(command1), str(command[2]))\n                    else:\n                        print(f"{Fore.LIGHTRED_EX}[normal] File Not Found{Fore.RESET}")\n\n                else:\n                    #print(command[1])\n                    #threading.Thread(target=self.cheackRandom, args=(int(command[1]))).start()\n                    self.cheackRandom(int(command[1]))\n\n                \n            except:\n                print(f"{Fore.LIGHTRED_EX}[command] set [long] | set [File]{Fore.RESET}\n")\n            \n            finally:\n                t1 = None\n                return True\n        \n        if command1 == "cls" or command1 == "Cls" or command1 == "clear" or command1 == "Clear": #cls | clear cmd\n            os.system("cls")\n            return True\n        \n\n        if command1 == "99" or command1 == "exit" or command1 == "Exit" or command1 == "leave" or command1 == "Leave":\n            print(f"{Fore.LIGHTRED_EX}GOOD BYE ...  press ENTER for exit{Fore.RESET}")\n            input()\n            exit()\n        \n        if command1 == "list" or command1 == "List":\n            print(self.listCheaker())\n\n        \n\n\n\n    def run(self):\n        os.system("cls")\n\n        text = f"""            \xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88              \n        \xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88          \xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88          \n      \xe2\x96\x88\xe2\x96\x88                  \xe2\x96\x88\xe2\x96\x88        \n    \xe2\x96\x88\xe2\x96\x88                      \xe2\x96\x88\xe2\x96\x88      \n    \xe2\x96\x88\xe2\x96\x88                      \xe2\x96\x88\xe2\x96\x88      \n  \xe2\x96\x88\xe2\x96\x88    \xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88    \xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88          \xe2\x96\x88\xe2\x96\x88    \n  \xe2\x96\x88\xe2\x96\x88  \xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88    \xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88        \xe2\x96\x88\xe2\x96\x88    \n  \xe2\x96\x88\xe2\x96\x88  \xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88    \xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88        \xe2\x96\x88\xe2\x96\x88    \n  \xe2\x96\x88\xe2\x96\x88  \xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88        \xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88        \xe2\x96\x88\xe2\x96\x88    \n  \xe2\x96\x88\xe2\x96\x88                          \xe2\x96\x88\xe2\x96\x88    Online\n  \xe2\x96\x88\xe2\x96\x88        \xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88      \xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88    \xe2\x96\x88\xe2\x96\x88    \n\xe2\x96\x88\xe2\x96\x88  \xe2\x96\x88\xe2\x96\x88      \xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88    \xe2\x96\x88\xe2\x96\x88        \xe2\x96\x88\xe2\x96\x88    \n\xe2\x96\x88\xe2\x96\x88  \xe2\x96\x92\xe2\x96\x92\xe2\x96\x88\xe2\x96\x88            \xe2\x96\x88\xe2\x96\x88  \xe2\x96\x88\xe2\x96\x88      \xe2\x96\x88\xe2\x96\x88  \n  \xe2\x96\x92\xe2\x96\x92  \xe2\x96\x92\xe2\x96\x92\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88        \xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88          \xe2\x96\x88\xe2\x96\x88\n  \xe2\x96\x92\xe2\x96\x92  \xe2\x96\x92\xe2\x96\x92    \xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88              \xe2\x96\x88\xe2\x96\x88  \n  \xe2\x96\x91\xe2\x96\x91\xe2\x96\x91\xe2\x96\x91\xe2\x96\x91\xe2\x96\x91          \xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88\xe2\x96\x88    \n\xe2\x96\x91\xe2\x96\x91\xe2\x96\x91\xe2\x96\x91\xe2\x96\x91\xe2\x96\x91\xe2\x96\x91\xe2\x96\x91\xe2\x96\x91\xe2\x96\x91                          \n\xe2\x96\x91\xe2\x96\x91  \xe2\x96\x91\xe2\x96\x91  \xe2\x96\x91\xe2\x96\x91                          \n  \xe2\x96\x91\xe2\x96\x91\xe2\x96\x91\xe2\x96\x91\xe2\x96\x91\xe2\x96\x91                            \n"""\n        faded = \'\'\n        red = 40\n\n        for line in text.splitlines():\n            faded += (f"\x1b[38;2;{red};0;220m{line}\x1b[0m\n")\n            if not red == 255:\n                red += 15\n                if red > 255:\n                    red = 255\n        print(center(faded))\n\n        if self.online == None:\n            self.online = True\n\n            while self.online:\n                command = input(self.getPath())\n\n                self.setCommand(command)\n                \n    \n        \n\n\n\ncheack = checker()\n'
